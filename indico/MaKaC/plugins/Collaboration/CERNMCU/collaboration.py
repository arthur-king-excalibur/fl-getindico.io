# -*- coding: utf-8 -*-
##
## $Id: collaboration.py,v 1.6 2009/04/25 17:30:35 dmartinc Exp $
##
## This file is part of CDS Indico.
## Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 CERN.
##
## CDS Indico is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## CDS Indico is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with CDS Indico; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from MaKaC.common.PickleJar import DictPickler
from MaKaC.common.timezoneUtils import nowutc
from MaKaC.plugins.Collaboration.base import CSBookingBase
from MaKaC.plugins.Collaboration.CERNMCU.common import CERNMCUException,\
    ParticipantPerson, ParticipantRoom, getCERNMCUOptionValueByName,\
    CERNMCUError
from MaKaC.common.utils import formatDateTime, validIP
from MaKaC.plugins.Collaboration.CERNMCU.mcu import MCU, MCUConfCommonParams, MCUTime,\
    paramsForLog, MCUParams, secondsToWait, MCUParticipantCommonParams

from xmlrpclib import Fault
from datetime import timedelta
from MaKaC.common.logger import Logger
import socket

class CSBooking(CSBookingBase):
    
    _hasStart = True
    _hasStop = True
    _hasCheckStatus = True
    
    _requiresServerCallForStart = True
    _requiresClientCallForStart = False
    
    _requiresServerCallForStop = True
    _requiresClientCallForStop = False
    
    _needsBookingParamsCheck = True
    _needsToBeNotifiedOnView = True
    
    _commonIndexes = ["All Videoconference"]
    
    _complexParameters = ["pin", "hasPin", "autoGenerateId", "customId", "participants"]
    
    def __init__(self, type, conf):
        CSBookingBase.__init__(self, type, conf)
        self._bookingParams = {
            "name": None,
            "description": None,
            "id": None
        }
        
        self._oldName = None
        self._pin = None
        self._autoGeneratedId = None #boolean storing if the id was generated by Indico (True) or chosen by user (False)
        self._customId = None #the custom id chosen by the user, if any
        self._participants = []
        
        self._created = False
        self._creationTriesCounter = 0
        self._active = False
        
    def getMCUStartTime(self):
        return MCUTime((self.getAdjustedStartDate('UTC') + timedelta(hours = getCERNMCUOptionValueByName("MCU_UTC_offset"))).strftime("%Y%m%dT%H:%M:%S"))
    
    def getDurationSeconds(self):
        diff = self.getEndDate() - self.getStartDate()
        return diff.days * 86400 + diff.seconds
    
    def setAutoGenerateId(self, autoGenerateId):
        self._autoGeneratedId = (autoGenerateId == 'yes')
        
    def getAutoGenerateId(self):
        if self._autoGeneratedId:
            return 'yes'
        else:
            return 'no'
        
    def setCustomId(self, customId):
        self._customId = customId
        
    def getCustomId(self):
        if self._autoGeneratedId:
            return ''
        else:
            return self._customId

    def getPin(self):
        """ This method returns the pin that will be displayed in the indico page
        """
        return self._pin
    
    def setPin(self, accessPassword):
        if accessPassword.strip() == "":
            self._pin = ""
        else:
            self._pin = accessPassword
            
    def getHasPin(self):
        return self._pin is not None
    
    def setHasPin(self, value):
        #ignore, will be called only on rollback
        pass
        
    
    def getParticipants(self):
        return DictPickler.pickle(self._participants)
    
    def setParticipants(self, participants):
        self._participants = []
        for p in participants:
            if p["type"] == 'person':
                self._participants.append(ParticipantPerson(p))
            elif p["type"] == "room":
                self._participants.append(ParticipantRoom(p))
        self._p_changed = 1
    

    
    ## overriding methods
    def _checkBookingParams(self):
        if len(self._bookingParams["name"].strip()) == 0:
            raise CERNMCUException("name parameter (" + str(self._bookingParams["name"]) +") is empty for booking with id: " + str(self._id))

        if len(self._bookingParams["description"].strip()) == 0:
            raise CERNMCUException("description parameter (" + str(self._bookingParams["description"]) +") is empty for booking with id: " + str(self._id))
        
        if not self._autoGeneratedId:
            if len(self._customId.strip()) == 0:
                raise CERNMCUException("customId parameter (" + str(self._customId) +") is empty for booking with id: " + str(self._id))
            else:
                try:
                    int(self._customId)
                except ValueError:
                    raise CERNMCUException("customId parameter (" + str(self._customId) +") is not an integer for booking with id: " + str(self._id))
        
        #if self.getAdjustedStartDate('UTC')  < (nowutc()):
        #    raise CERNMCUException("Cannot create booking in the past. Booking id: %s"% (str(self._id)))
        
        if self.getAdjustedEndDate('UTC')  < (nowutc()):
            raise CERNMCUException("End date cannot be in the past. Booking id: %s"% (str(self._id)))
        
        minStartDate = self.getConference().getAdjustedStartDate()
        if self.getAdjustedStartDate() < minStartDate:
            raise CERNMCUException("Cannot create a booking before the Indico event's start date. Please create it after %s"%(formatDateTime(minStartDate)))

        maxEndDate = self.getConference().getAdjustedEndDate()
        if self.getAdjustedStartDate() > maxEndDate:
            raise CERNMCUException("Cannot create a booking after before the Indico event's end date. Please create it after %s"%(formatDateTime(maxEndDate)))
        
        pSet = set()
        for p in self._participants:
            if not validIP(p.getIp()):
                raise CERNMCUException("Participant has not a correct ip. (ip string= " + p.getIp() + ")")
            
            if p.getType() == 'person':
                if not p.getFamilyName():
                    raise CERNMCUException("Participant (person) does not have family name.")
                if not p.getFirstName():
                    raise CERNMCUException("Participant (person) does not have first name.")
            elif p.getType() == 'room':
                if not p.getName():
                    raise CERNMCUException("Participant (room) does not have name.")
                
            fullName = p.getFullName()
            if fullName in pSet:
                raise CERNMCUException("At least two of the participants will have the same name in the MCU. Please change their name, affiliation, etc.")
            else:
                pSet.add(fullName)
                
        return False    
    
    def _create(self):
        if self._autoGeneratedId:
            if self._creationTriesCounter < 100:
                id = self._plugin.getGlobalData().getNewConferenceId()
            else:
                return CERNMCUError('tooManyTries', "Could not obtain ID")
        else:
            id = self._customId
            
        try:
            mcu = MCU.getInstance()
            params = MCUConfCommonParams(conferenceName = self._bookingParams["name"],
                                         numericId = str(id),
                                         startTime = self.getMCUStartTime(),
                                         durationSeconds = self.getDurationSeconds(),
                                         pin = self._pin,
                                         description = self._bookingParams["description"],
                                        )
            Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling conference.create with params: %s""" % (self._conf.getId(), self.getId(), str(paramsForLog(params))))
            answer = mcu.conference.create(params)
            Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling conference.create. Got answer: %s""" % (self._conf.getId(), self.getId(), str(answer)))
            
            for p in self._participants:
                try:
                    params = MCUParticipantCommonParams(conferenceName = self._bookingParams["name"],
                                                        participantName = p.getFullName(),
                                                        address = p.getIp()
                                                        )
                    Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participant.add with params: %s""" % (self._conf.getId(), self.getId(), str(paramsForLog(params))))
                    answer = mcu.participant.add(params)
                    Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participant.add. Got answer: %s""" % (self._conf.getId(), self.getId(), str(answer)))
                except Fault, e:
                    Logger.get('CERNMCU').warning("""Evt:%s, calling participant.add. Got error: %s""" % (self._conf.getId(), str(e)))
                    return self.handleFault('add', e)
            
            self._statusMessage = "Booking created"
            self._statusClass = "statusMessageOK"
            self._bookingParams["id"] = id
            self._oldName = self._bookingParams["name"]
            self._created = True
            self.checkCanStart()
            
        except Fault, e:
            Logger.get('CERNMCU').warning("""Evt:%s, calling conference.create. Got error: %s""" % (self._conf.getId(), str(e)))
            return self.handleFault('create', e)
        
        except socket.error, e:
            if e.message == 'timed out':
                raise CERNMCUException("Connection with the MCU timed out after %s seconds"%secondsToWait)
            else:
                raise e

    def _modify(self):
        if self._created:
            
            if self._autoGeneratedId:
                id = self._bookingParams["id"]
            else:
                id = self._customId
                
            try:
                mcu = MCU.getInstance()
                params = MCUConfCommonParams(conferenceName = self._oldName,
                                         newConferenceName = self._bookingParams["name"],
                                         numericId = str(id),
                                         startTime = self.getMCUStartTime(),
                                         durationSeconds = self.getDurationSeconds(),
                                         pin = self._pin,
                                         description = self._bookingParams["description"],
                                         )
                Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling conference.modify with params: %s""" % (self._conf.getId(), self.getId(), str(paramsForLog(params))))
                answer = mcu.conference.modify(params)
                Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling conference.modify. Got answer: %s""" % (self._conf.getId(), self.getId(), str(answer)))
                self._bookingParams["id"] = id
                self._oldName = self._bookingParams["name"]
                self._created = True
                self.checkCanStart()
                
                
            except Fault, e:
                Logger.get('CERNMCU').warning("""Evt:%s, booking:%s, calling conference.modify. Got error: %s""" % (self._conf.getId(), self.getId(), str(e)))
                return self.handleFault('modify', e)
            
            except socket.error, e:
                if e.message == 'timed out':
                    raise CERNMCUException("Connection with the MCU timed out after %s seconds"%secondsToWait)
                else:
                    raise e
        
        else: #not yet created because of errors: try to recreate
            self._create()
          
    def _start(self):
        self.checkCanStart()
        if self._canBeStarted:
            try:
                mcu = MCU.getInstance()
                for p in self._participants:
                    params = MCUParams(conferenceName = self._bookingParams["name"],
                                       participantName = p.getFullName())
                    Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participant.connect with params: %s""" % (self._conf.getId(), self.getId(), str(paramsForLog(params))))
                    answer = mcu.participant.connect(params)
                    Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participant.connect. Got answer: %s""" % (self._conf.getId(), self.getId(), str(answer)))
                
                self._statusMessage = "Conference started!"
                self._canBeStarted = False
                self._canBeStopped = True
                self._active = True
                
            except Fault, e:
                    Logger.get('CERNMCU').warning("""Evt:%s, booking:%s, calling participant.connect. Got error: %s""" % (self._conf.getId(), self.getId(), str(e)))
                    return self.handleFault('start', e)
                
            except socket.error, e:
                if e.message == 'timed out':
                    raise CERNMCUException("Connection with the MCU timed out after %s seconds"%secondsToWait)
                else:
                    raise e
        else:
            raise CERNMCUException("Conference cannot start yet!")
        
    def _stop(self):
        if self._canBeStopped:
            try:
                mcu = MCU.getInstance()
                for p in self._participants:
                    try:
                        params = MCUParams(conferenceName = self._bookingParams["name"],
                                           participantName = p.getFullName())
                        Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participant.disconnect with params: %s""" % (self._conf.getId(), self.getId(), str(paramsForLog(params))))
                        answer = mcu.participant.disconnect(params)
                        Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participant.disconnect. Got answer: %s""" % (self._conf.getId(), self.getId(), str(answer)))
                    except Fault, e:
                        Logger.get('CERNMCU').warning("""Evt:%s, booking:%s, calling participant.disconnect. Got error: %s""" % (self._conf.getId(), self.getId(), str(e)))
                        fault = self.handleFault('stop', e)
                        if fault:
                            return fault
                
                self._statusMessage = "Conference stopped"
                self._statusClass = "statusMessageOther"
                self._canBeStarted = True
                self._canBeStopped = False
                self._active = False
                
            except Fault, e:
                Logger.get('CERNMCU').warning("""Evt:%s, booking:%s, calling participant.disconnect. Got error: %s""" % (self._conf.getId(), self.getId(), str(e)))
                return self.handleFault('stop', e)
                
            except socket.error, e:
                if e.message == 'timed out':
                    raise CERNMCUException("Connection with the MCU timed out after %s seconds"%secondsToWait)
                else:
                    raise e
        else:
            raise CERNMCUException("Conference cannot start yet!")
          
    def _notifyOnView(self):
        self._checkStatus()
            
    def _checkStatus(self):
        self.checkCanStart()
                                        
    def _delete(self, oldName = None):
        if self._created:
            if oldName:
                name = oldName
            else:
                name = self._bookingParams["name"]
            
            try:
                mcu = MCU.getInstance()
                params = MCUParams(conferenceName = name)
                Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling conference.destroy with params: %s""" % (self._conf.getId(), self.getId(), str(paramsForLog(params))))
                answer = mcu.conference.destroy(params)
                Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling conference.destroy. Got answer: %s""" % (self._conf.getId(), self.getId(), str(answer)))
                
                if not oldName:
                    self._created = False
            except Fault, e:
                Logger.get('CERNMCU').warning("""Evt:%s, booking:%s, calling conference.destroy. Got error: %s""" % (self._conf.getId(), self.getId(), str(e)))
                if e.faultCode == 4: #conference didn't exist in the MCU, but we delete it from Indico anyway
                    pass
                else:
                    return self.handleFault('delete', e)
            except socket.error, e:
                if e.message == 'timed out':
                    raise CERNMCUException("Connection with the MCU timed out after %s seconds"%secondsToWait)
                else:
                    raise e
        else:
            self._error = False
    
    ## end of overrided methods
        
    def handleFault(self, operation, e):
        self._faultCode = e.faultCode
        self._faultString = e.faultString
        
        if operation == 'create' or operation == 'modify':
            if e.faultCode == 2: #duplicated name
                fault = CERNMCUError(e.faultCode)
                return fault
            elif e.faultCode == 18:  #duplicated ID
                if self._autoGeneratedId:
                    self._creationTriesCounter = self._creationTriesCounter + 1
                    return self._create()
                else:
                    fault = CERNMCUError(e.faultCode)
                    return fault
            else: #another error
                raise CERNMCUException("There was a problem with the MCU", e)
        
        elif operation == 'delete':
            raise CERNMCUException("There was a problem with the MCU", e)
        
        elif operation == 'add':
            raise CERNMCUException("There was a problem with the MCU", e)
        
        elif operation == 'start':
            raise CERNMCUException("There was a problem with the MCU", e)
        
        elif operation == 'stop':
            if e.faultCode == 201: #we tried to disconnect a participant that was not connected
                return None
            elif e.faultCode == 5: #we tried to disconnect a participant that didn't exist
                return None
            else:
                raise CERNMCUException("There was a problem with the MCU", e)
        
    def checkCanStart(self, changeMessage = True):
        now = nowutc()
        if self.getStartDate() < now and self.getEndDate() > now and not self._active:
            self._canBeStarted = True
            self._canBeStopped = False
            
            if changeMessage:
                self._statusMessage = "Ready to start!"
                self._statusClass = "statusMessageOK"
        else:
            self._canBeStarted = False
            if now > self.getEndDate() and changeMessage:
                self._statusMessage = "Already took place"
                self._statusClass = "statusMessageOther"
                self._needsToBeNotifiedOfDateChanges = False
                self._canBeNotifiedOfEventDateChanges = False
        
    def queryParticipants(self):
        #TODO later
        pass
        try:
            mcu = MCU.getInstance()
            params = MCUParams()
            Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participants.enumerate with params: %s""" % (self._conf.getId(), self.getId(), str(paramsForLog(params))))
            answer = mcu.participants.enumerate()
            Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participants.enumerate. Got answer: %s""" % (self._conf.getId(), self.getId(), str(answer)))

        except Fault, e:
            Logger.get('CERNMCU').warning("""Evt:%s, booking:%s, calling participants.enumerate. Got error: %s""" % (self._conf.getId(), self.getId(), str(e)))
            raise e
        except socket.error, e:
            if e.message == 'timed out':
                raise CERNMCUException("Connection with the MCU timed out after %s seconds"%secondsToWait)
            else:
                raise e